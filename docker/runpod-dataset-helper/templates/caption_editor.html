<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Caption Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 8px;
            font-size: 13px;
        }

        .tag-list {
            font-family: monospace;
            overflow-y: auto;
            background: #1a1a1a;
            color: #fff;
            border-radius: 4px;
            padding: 4px;
            font-size: 11px;
        }

        .tag-list:empty::before {
            content: "Tag counts will appear here";
            display: block;
            color: #888;
            font-style: italic;
            padding: 8px;
            text-align: center;
            font-size: 11px;
        }

        .tag-list-placeholder {
            color: #888;
            font-style: italic;
            padding: 8px;
            text-align: center;
            font-size: 11px;
        }

        .tag-row {
            display: flex;
            justify-content: space-between;
            padding: 2px 4px;
            border-radius: 2px;
            font-size: 11px;
        }

        .tag-row:nth-child(odd) {
            background: #2a2a2a;
        }

        .tag-row:hover {
            background: #3a3a3a;
        }

        .sticky-status-bar {
            position: sticky;
            top: 0;
            z-index: 1000;
            background: white;
            border-bottom: 1px solid #e1e5e9;
            padding: 6px 12px;
            margin: -12px -12px 8px -12px;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 8px;
        }

        .job-status-container {
            display: flex;
            flex-direction: column;
            gap: 4px;
            min-width: 250px;
            max-width: 400px;
        }

        .job-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            background: #f8f9fa;
            border-radius: 3px;
            border-left: 2px solid #667eea;
            font-size: 11px;
        }

        .job-item.running {
            border-left-color: #ffc107;
        }

        .job-item.completed {
            border-left-color: #28a745;
        }

        .job-item.error {
            border-left-color: #dc3545;
        }

        .job-name {
            font-weight: 600;
            color: #333;
            flex: 1;
            font-size: 11px;
        }

        .job-progress {
            color: #666;
            font-size: 10px;
        }

        .job-status-badge {
            padding: 1px 6px;
            border-radius: 8px;
            font-size: 9px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .job-status-badge.running {
            background: #fff3cd;
            color: #856404;
        }

        .job-status-badge.completed {
            background: #d4edda;
            color: #155724;
        }

        .job-status-badge.error {
            background: #f8d7da;
            color: #721c24;
        }

        .job-progress-bar {
            width: 100%;
            height: 2px;
            background: #e1e5e9;
            border-radius: 1px;
            overflow: hidden;
            margin-top: 2px;
        }

        .job-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            transition: width 0.3s ease;
        }

        .job-progress-fill.running {
            background: linear-gradient(90deg, #ffc107 0%, #ff9800 100%);
        }

        .job-progress-fill.completed {
            background: linear-gradient(90deg, #28a745 0%, #20c997 100%);
        }

        .no-jobs {
            color: #666;
            font-size: 11px;
            font-style: italic;
        }

        .sticky-tag-panel {
            position: sticky;
            top: 32px;
            z-index: 999;
            background: #1a1a1a;
            border-radius: 4px;
            padding: 6px;
            max-height: 200px;
            overflow-y: auto;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
            margin-bottom: 8px;
            transition: max-height 0.3s ease, padding 0.3s ease;
        }

        .sticky-tag-panel.collapsed {
            max-height: 32px;
            overflow: hidden;
            padding-bottom: 6px;
        }

        .sticky-tag-panel.collapsed .tag-list {
            display: none;
        }

        .sticky-tag-panel.collapsed h3 {
            margin-bottom: 0;
        }

        .sticky-tag-panel h3 {
            color: #fff;
            margin-bottom: 4px;
            font-size: 12px;
            border-bottom: 1px solid #444;
            padding-bottom: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            user-select: none;
        }

        .sticky-tag-panel h3:hover {
            color: #ccc;
        }

        .tag-toggle-btn {
            background: transparent;
            border: none;
            color: #fff;
            font-size: 10px;
            cursor: pointer;
            padding: 0 3px;
            transition: transform 0.3s ease;
        }

        .tag-toggle-btn:hover {
            color: #ccc;
        }

        .sticky-tag-panel.collapsed .tag-toggle-btn {
            transform: rotate(180deg);
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .header {
            background: #000;
            color: white;
            padding: 8px 12px;
            text-align: center;
        }

        .header h1 {
            font-size: 1.2em;
            margin-bottom: 2px;
        }

        .header p {
            font-size: 11px;
            opacity: 0.9;
        }

        .nav-links {
            margin-top: 4px;
        }

        .nav-links a {
            color: white;
            text-decoration: none;
            margin: 0 4px;
            padding: 3px 8px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 3px;
            transition: background-color 0.3s ease;
            font-size: 11px;
        }

        .nav-links a:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }

        .content {
            padding: 12px;
        }

        .form-section {
            background: #f8f9fa;
            padding: 8px;
            border-radius: 4px;
            margin-bottom: 8px;
        }

        .form-group {
            margin-bottom: 8px;
        }

        .form-group label {
            display: block;
            margin-bottom: 3px;
            font-weight: 600;
            color: #333;
            font-size: 11px;
        }

        .form-group input {
            width: 100%;
            padding: 4px 6px;
            border: 1px solid #e1e5e9;
            border-radius: 3px;
            font-size: 12px;
            transition: border-color 0.3s ease;
        }

        .form-group input:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 4px 10px;
            border-radius: 3px;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s ease;
            margin-right: 4px;
            margin-bottom: 4px;
        }

        .btn:hover {
            transform: translateY(-1px);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .status {
            padding: 4px 8px;
            border-radius: 3px;
            margin-bottom: 6px;
            font-weight: 600;
            font-size: 11px;
        }

        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .images-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 8px;
            margin-top: 8px;
        }

        .image-card {
            background: white;
            border: 1px solid #e1e5e9;
            border-radius: 4px;
            overflow: hidden;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .image-card:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        }

        .image-container {
            width: 100%;
            height: 180px;
            overflow: hidden;
            background: #f8f9fa;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .image-container img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            position: absolute;
            top: 0;
            left: 0;
        }

        .image-placeholder {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .caption-container {
            padding: 6px;
        }

        .caption-label {
            font-size: 10px;
            color: #666;
            margin-bottom: 3px;
            font-weight: 600;
        }

        .caption-textarea {
            width: 100%;
            min-height: 50px;
            padding: 4px 6px;
            border: 1px solid #e1e5e9;
            border-radius: 3px;
            font-size: 11px;
            font-family: inherit;
            resize: vertical;
            transition: border-color 0.3s ease;
        }

        .caption-textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .caption-textarea.saving {
            border-color: #ffc107;
        }

        .caption-textarea.saved {
            border-color: #28a745;
        }

        .save-indicator {
            font-size: 9px;
            margin-top: 2px;
            color: #666;
        }

        .save-indicator.saving {
            color: #ffc107;
        }

        .save-indicator.saved {
            color: #28a745;
        }

        .save-indicator.error {
            color: #dc3545;
        }

        .loading {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .hidden {
            display: none;
        }

        .empty-state {
            text-align: center;
            padding: 20px 10px;
            color: #666;
            font-size: 11px;
        }

        .empty-state h3 {
            margin-bottom: 4px;
            color: #333;
            font-size: 12px;
        }

        .image-container img {
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .image-container img.loaded {
            opacity: 1;
        }

        .image-container img.loading {
            opacity: 0.5;
        }

        .image-placeholder {
            width: 100%;
            height: 180px;
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: loading 1.5s infinite;
        }

        @keyframes loading {
            0% {
                background-position: 200% 0;
            }

            100% {
                background-position: -200% 0;
            }
        }

        @media (max-width: 1200px) {
            .sticky-tag-panel {
                max-height: 180px;
            }

            .sticky-status-bar {
                flex-direction: column;
                align-items: flex-start;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>üìù Caption Editor</h1>
            <p>Edit image captions in real-time</p>
            <div class="nav-links">
                <a href="/">üöÄ Training UI</a>
            </div>
        </div>

        <div class="content">
            <div class="form-section">
                <div class="form-group">
                    <label for="directoryInput">Directory Path:</label>
                    <input type="text" id="directoryInput" placeholder="/path/to/image/directory" value="">
                </div>
                <button class="btn" id="loadBtn" onclick="loadImages()">Load Images</button>
                <div id="statusMessage" class="status hidden" style="margin-top: 15px;"></div>
            </div>

            <div class="sticky-status-bar">
                <div>
                    <button class="btn" onclick="confirmAndRun('all')">üìù Re-caption All</button>
                    <button class="btn" onclick="confirmAndRun('empty')">üìù Caption Empty</button>
                </div>
                <div class="job-status-container" id="jobStatusContainer">
                    <div class="no-jobs" id="noJobsMessage">No running jobs</div>
                </div>
            </div>

            <div class="sticky-tag-panel" id="tagPanel">
                <h3 onclick="toggleTagPanel()">
                    <span>üìä Tag Counts</span>
                    <button class="tag-toggle-btn" onclick="event.stopPropagation(); toggleTagPanel()">‚ñº</button>
                </h3>
                <div id="tagList" class="tag-list"></div>
            </div>

            <div id="imagesContainer" class="hidden">
                <div class="status info" id="imageCount"></div>
                <div class="images-grid" id="imagesGrid"></div>
            </div>

            <div id="emptyState" class="empty-state">
                <h3>No images loaded</h3>
                <p>Enter a directory path and click "Load Images" to start editing captions</p>
            </div>
        </div>
    </div>

    <script>
        let currentDirectory = '';
        let saveTimeouts = {};
        let allImages = [];
        let loadedImages = new Set();
        let pendingLoads = [];
        let loadingQueue = [];
        let isProcessingQueue = false;
        let failedLoads = new Map(); // Track failed loads: image_path -> { retryCount, timeoutId }
        let queueTimeoutId = null; // Track queue processing timeout
        const BATCH_SIZE = 5;
        const BATCH_DELAY = 300; // ms between batches
        const RETRY_DELAY = 10000; // 10 seconds
        const MAX_RETRIES = 3; // Maximum number of retries per image
        let intersectionObserver = null;
        
        // Job tracking
        let activeJobs = new Map(); // jobId -> { name, status, done, total, startTime, jobId }
        let jobPollInterval = null;

        async function loadImages() {
            const directory = document.getElementById('directoryInput').value.trim();

            if (!directory) {
                showStatus('Please enter a directory path', 'error');
                return;
            }

            // Clear all pending operations if directory changed
            if (currentDirectory && currentDirectory !== directory) {
                clearAllRetries();
                // Stop processing queue
                isProcessingQueue = false;
                loadingQueue = [];
                pendingLoads = [];
            }

            const loadBtn = document.getElementById('loadBtn');
            loadBtn.disabled = true;
            loadBtn.innerHTML = '<span class="loading"></span> Loading...';

            const statusMessage = document.getElementById('statusMessage');
            statusMessage.className = 'status info';
            statusMessage.textContent = 'Loading images...';
            statusMessage.classList.remove('hidden');

            try {
                const response = await fetch('/api/list_images', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        directory: directory
                    })
                });

                const data = await response.json();

                if (response.ok) {
                    // Clear all pending operations before loading new directory
                    clearAllRetries();

                    // Stop processing queue
                    isProcessingQueue = false;
                    loadingQueue = [];
                    pendingLoads = [];
                    loadedImages.clear();

                    currentDirectory = directory;
                    allImages = data.images;

                    displayImages(data.images);
                    updateTotalTags();
                    showStatus(`Found ${data.count} image(s) - loading thumbnails...`, 'success');
                } else {
                    showStatus('Error: ' + data.error, 'error');
                }
            } catch (error) {
                showStatus('Error loading images: ' + error.message, 'error');
            } finally {
                loadBtn.disabled = false;
                loadBtn.innerHTML = 'Load Images';
            }
        }

        function clearAllRetries() {
            // Clear all retry timeouts
            failedLoads.forEach((info) => {
                if (info.timeoutId) {
                    clearTimeout(info.timeoutId);
                }
            });
            failedLoads.clear();

            // Clear queue processing timeout
            if (queueTimeoutId) {
                clearTimeout(queueTimeoutId);
                queueTimeoutId = null;
            }
        }

        function displayImages(images) {
            const imagesContainer = document.getElementById('imagesContainer');
            const imagesGrid = document.getElementById('imagesGrid');
            const emptyState = document.getElementById('emptyState');
            const imageCount = document.getElementById('imageCount');

            if (images.length === 0) {
                imagesContainer.classList.add('hidden');
                emptyState.classList.remove('hidden');
                // Clear retries even if no images
                clearAllRetries();
                return;
            }

            // Clear all pending retries and operations before loading new images
            clearAllRetries();
            isProcessingQueue = false;
            loadingQueue = [];
            pendingLoads = [];

            imagesContainer.classList.remove('hidden');
            emptyState.classList.add('hidden');
            imageCount.textContent = `Found ${images.length} image(s)`;

            imagesGrid.innerHTML = '';

            // Disconnect previous observer if exists
            if (intersectionObserver) {
                intersectionObserver.disconnect();
                intersectionObserver = null;
            }

            // Create Intersection Observer for lazy loading
            intersectionObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const container = entry.target;
                        const img = container.querySelector('img');
                        if (img && img.dataset.imageData) {
                            const imageData = JSON.parse(img.dataset.imageData);

                            // Check if image needs to be loaded (not loaded yet, or failed and needs retry)
                            const needsLoad = !loadedImages.has(imageData.image_path) && !pendingLoads.includes(imageData.image_path);
                            const needsRetry = failedLoads.has(imageData.image_path) &&
                                failedLoads.get(imageData.image_path).retryCount < MAX_RETRIES &&
                                !failedLoads.get(imageData.image_path).timeoutId;

                            if (imageData && (needsLoad || needsRetry)) {
                                pendingLoads.push(imageData.image_path);
                                loadingQueue.push({ imgElement: img, imageData: imageData, isRetry: needsRetry });
                                // Unobserve once queued
                                intersectionObserver.unobserve(container);

                                // Start processing queue if not already processing
                                if (!isProcessingQueue) {
                                    processLoadingQueue();
                                }
                            }
                        }
                    }
                });
            }, {
                rootMargin: '200px' // Start loading 200px before entering viewport
            });

            // Create cards for all images
            images.forEach((image, index) => {
                const card = document.createElement('div');
                card.className = 'image-card';

                // Create image element with placeholder
                const imageContainer = document.createElement('div');
                imageContainer.className = 'image-container';

                const placeholder = document.createElement('div');
                placeholder.className = 'image-placeholder';
                placeholder.id = `placeholder-${index}`;

                const img = document.createElement('img');
                img.dataset.imageData = JSON.stringify(image);
                img.dataset.index = index;
                img.alt = image.filename;
                img.style.display = 'none';
                img.style.width = '100%';
                img.style.height = '100%';
                img.style.objectFit = 'contain';
                // Don't set onload/onerror here - they'll be set in loadImage()

                imageContainer.appendChild(placeholder);
                imageContainer.appendChild(img);

                // Create caption container
                const captionContainer = document.createElement('div');
                captionContainer.className = 'caption-container';

                const captionLabel = document.createElement('div');
                captionLabel.className = 'caption-label';
                captionLabel.textContent = image.filename;

                const captionTextarea = document.createElement('textarea');
                captionTextarea.className = 'caption-textarea';
                captionTextarea.value = image.caption;
                captionTextarea.placeholder = 'Enter caption...';
                captionTextarea.dataset.captionFilename = image.caption_filename;

                const saveIndicator = document.createElement('div');
                saveIndicator.className = 'save-indicator';
                saveIndicator.textContent = '';

                // Handle caption changes with debouncing
                captionTextarea.addEventListener('input', function () {
                    clearTimeout(saveTimeouts[image.caption_filename]);

                    captionTextarea.classList.remove('saved');
                    captionTextarea.classList.add('saving');
                    saveIndicator.textContent = 'Saving...';
                    saveIndicator.className = 'save-indicator saving';

                    saveTimeouts[image.caption_filename] = setTimeout(() => {
                        saveCaption(image.caption_filename, captionTextarea.value);
                    }, 1000);
                });

                captionContainer.appendChild(captionLabel);
                captionContainer.appendChild(captionTextarea);
                captionContainer.appendChild(saveIndicator);

                card.appendChild(imageContainer);
                card.appendChild(captionContainer);

                imagesGrid.appendChild(card);

                // Observe the image container (not the hidden img) for lazy loading
                intersectionObserver.observe(imageContainer);
                imageContainer.dataset.imageIndex = index;
            });

            // Trigger initial load for visible images immediately
            requestAnimationFrame(() => {
                // Force check all images that are in viewport
                const containers = document.querySelectorAll('.image-container');
                containers.forEach(container => {
                    const rect = container.getBoundingClientRect();
                    const isVisible = rect.top < window.innerHeight + 200 && rect.bottom > -200;
                    if (isVisible) {
                        const img = container.querySelector('img');
                        if (img && img.dataset.imageData) {
                            const imageData = JSON.parse(img.dataset.imageData);
                            const needsLoad = !loadedImages.has(imageData.image_path) && !pendingLoads.includes(imageData.image_path);
                            const needsRetry = failedLoads.has(imageData.image_path) &&
                                failedLoads.get(imageData.image_path).retryCount < MAX_RETRIES &&
                                !failedLoads.get(imageData.image_path).timeoutId;

                            if (needsLoad || needsRetry) {
                                pendingLoads.push(imageData.image_path);
                                loadingQueue.push({ imgElement: img, imageData: imageData, isRetry: needsRetry });
                            }
                        }
                    }
                });

                if (!isProcessingQueue && loadingQueue.length > 0) {
                    processLoadingQueue();
                }
            });

            addSingleCaptionButtons();
        }

        function processLoadingQueue() {
            // Clear any existing queue timeout
            if (queueTimeoutId) {
                clearTimeout(queueTimeoutId);
                queueTimeoutId = null;
            }

            if (isProcessingQueue && loadingQueue.length === 0) {
                isProcessingQueue = false;
                return;
            }

            if (loadingQueue.length === 0) {
                isProcessingQueue = false;
                return;
            }

            isProcessingQueue = true;

            // Process a batch
            const batch = loadingQueue.splice(0, BATCH_SIZE);

            batch.forEach((item, index) => {
                setTimeout(() => {
                    loadImage(item.imgElement, item.imageData, item.isRetry || false);
                }, index * 100); // Stagger loads within batch by 100ms
            });

            // Process next batch after delay
            queueTimeoutId = setTimeout(() => {
                queueTimeoutId = null;
                processLoadingQueue();
            }, BATCH_DELAY);
        }

        function loadImage(imgElement, imageData, isRetry = false) {
            // Don't load if already successfully loaded (unless it's a retry)
            if (!isRetry && loadedImages.has(imageData.image_path)) {
                // Check if it's actually loaded (has src and displayed)
                if (imgElement.src && imgElement.style.display !== 'none') {
                    return;
                }
            }

            // Check retry count
            const failedInfo = failedLoads.get(imageData.image_path);
            if (failedInfo && failedInfo.retryCount >= MAX_RETRIES) {
                // Max retries reached, show error
                showImageError(imgElement);
                return;
            }

            // Mark as attempted (but don't mark as successfully loaded yet)
            if (!isRetry) {
                loadedImages.add(imageData.image_path);
            }

            const index = pendingLoads.indexOf(imageData.image_path);
            if (index > -1) {
                pendingLoads.splice(index, 1);
            }

            // Clear any existing retry timeout
            if (failedInfo && failedInfo.timeoutId) {
                clearTimeout(failedInfo.timeoutId);
            }

            imgElement.classList.add('loading');

            // Get current failed info before setting up handlers
            const currentFailedInfo = failedLoads.get(imageData.image_path);

            // Load thumbnail first (smaller, faster) - 300px max dimension
            const thumbnailUrl = `/api/get_image?path=${encodeURIComponent(imageData.image_path)}&thumbnail=true&size=300`;

            // Set up one-time load handlers
            const onThumbnailLoad = () => {
                // Success - remove from failed loads and clear retry timeout
                const failedInfo = failedLoads.get(imageData.image_path);
                if (failedInfo && failedInfo.timeoutId) {
                    clearTimeout(failedInfo.timeoutId);
                }
                failedLoads.delete(imageData.image_path);

                imgElement.classList.remove('loading');
                imgElement.classList.add('loaded');
                imgElement.style.display = 'block';
                const placeholderEl = document.getElementById(`placeholder-${imgElement.dataset.index}`);
                if (placeholderEl) {
                    placeholderEl.style.display = 'none';
                    placeholderEl.textContent = ''; // Clear retry message
                }

                // Load full image after a delay if still in viewport
                setTimeout(() => {
                    if (imgElement.offsetParent !== null) { // Check if still visible
                        const fullImageUrl = `/api/get_image?path=${encodeURIComponent(imageData.image_path)}`;
                        const fullImg = new Image();
                        fullImg.onload = () => {
                            imgElement.src = fullImageUrl;
                        };
                        fullImg.onerror = () => {
                            // Keep thumbnail if full image fails - don't retry full image
                        };
                        fullImg.src = fullImageUrl;
                    }
                }, 2000); // Wait 2 seconds before loading full image
            };

            const onThumbnailError = () => {
                imgElement.classList.remove('loading');

                // Track failed load
                const failedInfo = failedLoads.get(imageData.image_path);
                const currentRetryCount = failedInfo ? failedInfo.retryCount + 1 : 1;

                if (currentRetryCount < MAX_RETRIES) {
                    // Schedule retry
                    const timeoutId = setTimeout(() => {
                        // Check if image is still in viewport before retrying
                        const container = imgElement.closest('.image-container');
                        if (container) {
                            const rect = container.getBoundingClientRect();
                            const isVisible = rect.top < window.innerHeight + 200 && rect.bottom > -200;
                            if (isVisible) {
                                loadImage(imgElement, imageData, true);
                            } else {
                                // Not visible, wait for intersection observer to trigger
                                failedLoads.set(imageData.image_path, {
                                    retryCount: currentRetryCount,
                                    timeoutId: null
                                });
                            }
                        }
                    }, RETRY_DELAY);

                    failedLoads.set(imageData.image_path, {
                        retryCount: currentRetryCount,
                        timeoutId: timeoutId
                    });

                    // Show retry indicator
                    const placeholderEl = document.getElementById(`placeholder-${imgElement.dataset.index}`);
                    if (placeholderEl) {
                        placeholderEl.textContent = `Retrying... (${currentRetryCount}/${MAX_RETRIES})`;
                        placeholderEl.style.display = 'flex';
                        placeholderEl.style.alignItems = 'center';
                        placeholderEl.style.justifyContent = 'center';
                        placeholderEl.style.color = '#ffc107';
                    }
                } else {
                    // Max retries reached
                    showImageError(imgElement);
                }
            };

            // Remove old handlers and add new ones
            imgElement.onload = onThumbnailLoad;
            imgElement.onerror = onThumbnailError;

            // Start loading
            imgElement.src = thumbnailUrl;
        }

        function showImageError(imgElement) {
            imgElement.src = 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" width="200" height="200"%3E%3Ctext x="50%25" y="50%25" text-anchor="middle" dy=".3em" fill="%23dc3545"%3EImage load failed%3C/text%3E%3C/svg%3E';
            imgElement.classList.remove('loading');
            imgElement.classList.add('loaded');
            imgElement.style.display = 'block';
            const placeholderEl = document.getElementById(`placeholder-${imgElement.dataset.index}`);
            if (placeholderEl) {
                placeholderEl.style.display = 'none';
            }

            // Remove from failed loads since we've given up
            const imageData = imgElement.dataset.imageData ? JSON.parse(imgElement.dataset.imageData) : null;
            if (imageData) {
                failedLoads.delete(imageData.image_path);
            }
        }

        async function saveCaption(captionFilename, captionText) {
            try {
                const response = await fetch('/api/save_caption', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        directory: currentDirectory,
                        caption_filename: captionFilename,
                        caption: captionText
                    })
                });

                const data = await response.json();

                if (response.ok) {
                    // Find the textarea and update its status
                    const textarea = document.querySelector(`textarea[data-caption-filename="${captionFilename}"]`);
                    const indicator = textarea?.nextElementSibling;

                    if (textarea) {
                        textarea.classList.remove('saving');
                        textarea.classList.add('saved');
                    }

                    if (indicator) {
                        indicator.textContent = 'Saved';
                        indicator.className = 'save-indicator saved';

                        // Clear the saved indicator after 2 seconds
                        setTimeout(() => {
                            indicator.textContent = '';
                            if (textarea) {
                                textarea.classList.remove('saved');
                            }
                        }, 2000);
                    }
                } else {
                    throw new Error(data.error || 'Failed to save caption');
                }
            } catch (error) {
                console.error('Error saving caption:', error);
                const textarea = document.querySelector(`textarea[data-caption-filename="${captionFilename}"]`);
                const indicator = textarea?.nextElementSibling;

                if (textarea) {
                    textarea.classList.remove('saving', 'saved');
                }

                if (indicator) {
                    indicator.textContent = 'Error saving';
                    indicator.className = 'save-indicator error';
                }
            }
        }

        function showStatus(message, type) {
            const statusMessage = document.getElementById('statusMessage');
            statusMessage.textContent = message;
            statusMessage.className = `status ${type}`;
            statusMessage.classList.remove('hidden');
        }

        // Job management functions
        function addJob(jobId, jobName, mode = 'batch') {
            activeJobs.set(jobId, {
                jobId: jobId,
                name: jobName,
                status: 'running',
                done: 0,
                total: 0,
                startTime: Date.now(),
                mode: mode
            });
            updateJobStatusDisplay();
            startJobPolling();
        }

        function updateJob(jobId, status, done, total, error) {
            const job = activeJobs.get(jobId);
            if (job) {
                job.status = status;
                if (done !== undefined) job.done = done;
                if (total !== undefined) job.total = total;
                if (error) job.error = error;
                
                if (status === 'completed' || status === 'error') {
                    // Remove completed/error jobs after 5 seconds
                    setTimeout(() => {
                        activeJobs.delete(jobId);
                        updateJobStatusDisplay();
                        if (activeJobs.size === 0) {
                            stopJobPolling();
                        }
                    }, 5000);
                }
            }
            updateJobStatusDisplay();
        }

        function updateJobStatusDisplay() {
            const container = document.getElementById('jobStatusContainer');
            const noJobsMessage = document.getElementById('noJobsMessage');
            
            if (activeJobs.size === 0) {
                noJobsMessage.style.display = 'block';
                // Remove all job items
                const jobItems = container.querySelectorAll('.job-item');
                jobItems.forEach(item => item.remove());
                return;
            }
            
            noJobsMessage.style.display = 'none';
            
            // Remove existing job items
            const existingItems = container.querySelectorAll('.job-item');
            existingItems.forEach(item => item.remove());
            
            // Add current jobs
            activeJobs.forEach((job, jobId) => {
                const jobItem = createJobItem(job);
                container.appendChild(jobItem);
            });
        }

        function createJobItem(job) {
            const item = document.createElement('div');
            item.className = `job-item ${job.status}`;
            item.dataset.jobId = job.jobId;
            
            const name = document.createElement('div');
            name.className = 'job-name';
            name.textContent = job.name;
            
            const statusBadge = document.createElement('span');
            statusBadge.className = `job-status-badge ${job.status}`;
            statusBadge.textContent = job.status;
            
            const progress = document.createElement('div');
            progress.className = 'job-progress';
            
            let progressText = '';
            if (job.total > 0) {
                const percentage = Math.round((job.done / job.total) * 100);
                progressText = `${job.done}/${job.total} (${percentage}%)`;
            } else {
                progressText = 'Starting...';
            }
            progress.textContent = progressText;
            
            const progressBar = document.createElement('div');
            progressBar.className = 'job-progress-bar';
            const progressFill = document.createElement('div');
            progressFill.className = `job-progress-fill ${job.status}`;
            
            if (job.total > 0) {
                progressFill.style.width = `${(job.done / job.total) * 100}%`;
            } else {
                progressFill.style.width = '0%';
            }
            
            progressBar.appendChild(progressFill);
            
            item.appendChild(name);
            item.appendChild(statusBadge);
            item.appendChild(progress);
            item.appendChild(progressBar);
            
            return item;
        }

        function startJobPolling() {
            if (jobPollInterval) return; // Already polling
            
            jobPollInterval = setInterval(() => {
                if (activeJobs.size === 0) {
                    stopJobPolling();
                    return;
                }
                
                // Poll each active job
                activeJobs.forEach((job, jobId) => {
                    if (job.status === 'running') {
                        // Try to get job status from backend
                        // Check if backend supports /api/autotag/status/<job_id>
                        if (jobId.startsWith('batch_')) {
                            // For batch jobs without backend job_id, simulate progress
                            // In a real implementation, you'd poll the backend
                            // For now, we'll just keep it running until manually updated
                        } else {
                            // Try to fetch job status from backend
                            fetch(`/api/autotag/status/${jobId}`)
                                .then(res => res.json())
                                .then(data => {
                                    if (data.status) {
                                        updateJob(jobId, data.status, data.done || 0, data.total || 0, data.error);
                                    }
                                })
                                .catch(err => {
                                    // If endpoint doesn't exist or fails, keep job as is
                                    console.log('Job status check failed:', err);
                                });
                        }
                    }
                });
            }, 2000); // Poll every 2 seconds
        }

        function stopJobPolling() {
            if (jobPollInterval) {
                clearInterval(jobPollInterval);
                jobPollInterval = null;
            }
        }

        function toggleTagPanel() {
            const panel = document.getElementById('tagPanel');
            panel.classList.toggle('collapsed');
        }

        function showDummyTags() {
            const container = document.getElementById('tagList');
            container.innerHTML = '';
            
            const dummyTags = [
                ['1girl', 45],
                ['solo', 32],
                ['long_hair', 28],
                ['smile', 24],
                ['standing', 19],
                ['simple_background', 15],
                ['blonde_hair', 12],
                ['blue_eyes', 10],
                ['dress', 8],
                ['outfit', 7]
            ];

            for (const [tag, count] of dummyTags) {
                const row = document.createElement('div');
                row.className = 'tag-row';
                row.textContent = `${tag} ‚Äî ${count}`;
                container.appendChild(row);
            }
        }

        async function updateTotalTags() {
            if (!currentDirectory) {
                // Show dummy data when no directory
                showDummyTags();
                return;
            }

            try {
                const response = await fetch(
                    `/api/tags_count?directory=${encodeURIComponent(currentDirectory)}`
                );
                const tags = await response.json();

                if (!response.ok) {
                    showDummyTags();
                    return;
                }

                const container = document.getElementById('tagList');
                container.innerHTML = '';

                const sorted = Object.entries(tags)
                    .sort((a, b) => b[1] - a[1]); // highest count first

                if (sorted.length === 0) {
                    showDummyTags();
                    return;
                }

                for (const [tag, count] of sorted) {
                    const row = document.createElement('div');
                    row.className = 'tag-row';
                    row.textContent = `${tag} ‚Äî ${count}`;
                    container.appendChild(row);
                }
            } catch (err) {
                console.error('Error fetching tags:', err);
                showDummyTags();
            }
        }

        // Call after save or autotag
        async function refreshAfterSaveOrAutotag() {
            await updateTotalTags();
            // Optionally reload images if needed
        }

        // Confirm and run batch caption
        function confirmAndRun(mode) {
            const msg = mode === 'all'
                ? 'Are you sure you want to re-caption all images?'
                : 'Are you sure you want to caption only empty images?';
            if (!confirm(msg)) return;

            const jobName = mode === 'all' ? 'Re-caption All Images' : 'Caption Empty Images';
            const jobId = 'batch_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            
            // Add job to tracking
            addJob(jobId, jobName, 'batch');
            
            // Start batch job
            fetch(`/api/caption_batch?mode=${mode}`, { method: 'POST' })
                .then(res => res.json())
                .then(data => {
                    // If backend returns a job_id, use it
                    if (data.job_id) {
                        // Update job with backend job_id
                        const job = activeJobs.get(jobId);
                        if (job) {
                            activeJobs.delete(jobId);
                            job.jobId = data.job_id;
                            activeJobs.set(data.job_id, job);
                        }
                    }
                    
                    // Update job with initial status
                    if (data.total) {
                        updateJob(data.job_id || jobId, 'running', 0, data.total);
                    }
                    
                    showStatus(data.message || 'Batch job started', 'success');
                    updateTotalTags();
                })
                .catch(err => {
                    updateJob(jobId, 'error', 0, 0, err.message);
                    showStatus('Error starting batch job: ' + err.message, 'error');
                });
        }

        // Single caption per image
        function addSingleCaptionButtons() {
            const textareas = document.querySelectorAll('.caption-textarea');
            textareas.forEach(textarea => {
                const btn = document.createElement('button');
                btn.textContent = 'Caption';
                btn.className = 'btn';
                btn.style.marginTop = '5px';
                btn.onclick = () => {
                    if (!confirm('Generate caption for this image?')) return;
                    const imageData = JSON.parse(textarea.parentElement.previousElementSibling.querySelector('img').getAttribute('data-image-data'));
                    //const imageData = JSON.parse(textarea.previousElementSibling.querySelector('img').dataset.imageData);

                    const jobId = 'single_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                    const jobName = `Caption: ${imageData.filename}`;
                    addJob(jobId, jobName, 'single');
                    updateJob(jobId, 'running', 0, 1);

                    fetch('/api/caption_single', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            image_path: imageData.image_path
                        })
                    })
                    .then(res => res.json())
                    .then(data => {
                        if (data.caption) {
                            textarea.value = data.caption;
                            saveCaption(imageData.caption_filename, data.caption);
                            refreshAfterSaveOrAutotag();
                            updateJob(jobId, 'completed', 1, 1);
                        } else {
                            updateJob(jobId, 'error', 0, 1, 'No caption returned');
                        }
                    })
                    .catch(err => {
                        console.error(err);
                        updateJob(jobId, 'error', 0, 1, err.message);
                    });
                };
                textarea.parentNode.appendChild(btn);
            });
        }

        async function refreshCaptions() {
            if (!currentDirectory) return;

            try {
                const response = await fetch('/api/list_images', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ directory: currentDirectory })
                });

                const data = await response.json();
                if (response.ok && data.images) {
                    data.images.forEach(image => {
                        const textarea = document.querySelector(
                            `textarea[data-caption-filename="${image.caption_filename}"]`
                        );
                        if (textarea && textarea.value !== image.caption) {
                            textarea.value = image.caption;
                            // Optional: show a small indicator
                            const indicator = textarea.nextElementSibling;
                            if (indicator) {
                                indicator.textContent = 'Updated';
                                indicator.className = 'save-indicator saved';
                                setTimeout(() => {
                                    indicator.textContent = '';
                                    indicator.className = 'save-indicator';
                                }, 1500);
                            }
                        }
                    });

                    // Refresh total tags
                    updateTotalTags();
                }
            } catch (err) {
                console.error('Error refreshing captions:', err);
            }
        }

        // Initialize with dummy data on page load
        document.addEventListener('DOMContentLoaded', function() {
            showDummyTags();
        });
    </script>
</body>

</html>